# []byte、[]rune 和 string 的区别详解

在 Go 语言中，`string`、`byte`（`[]byte`）和`rune`（`[]rune`）是处理文本数据的三种核心类型，它们在底层实现、使用场景和操作方式上存在显著差异。以下是它们的详细对比：

## 1. 基本概念

### string

- **定义**：不可变的 UTF-8 编码字节序列
- **底层结构**：`stringStruct`（包含指针和长度）
- **特点**：
  - 不可变：创建后不能修改内容
  - 长度是字节数，不是字符数（如"你好"的`len`是 6）
  - 以 UTF-8 编码存储，支持所有 Unicode 字符
  - 可直接赋值、拼接、比较

### byte

- **定义**：`uint8`的别名，表示单个字节（8 位无符号整数）
- **特点**：
  - 用于处理 ASCII 或单字节字符
  - 通常与`[]byte`一起使用，处理二进制数据

### rune

- **定义**：`int32`的别名，表示 Unicode 码点
- **特点**：
  - 用于处理多字节字符（如中文、emoji）
  - 每个 rune 对应一个 Unicode 字符
  - 与 UTF-8 编码的多字节序列一一映射

### []byte

- **定义**：`byte`类型的切片，可变的字节序列
- **特点**：
  - 可以修改内容
  - 通常用于网络传输、文件读写等场景
  - 通过`[]byte(str)`可以将字符串转换为字节切片

### []rune

- **定义**：`rune`类型的切片，可变的 Unicode 字符序列
- **特点**：
  - 可以修改内容
  - 用于处理多字节字符，按字符而不是字节进行操作
  - 通过`[]rune(str)`可以将字符串转换为 rune 切片

## 2. 核心区别对比表

| 特性         | string                     | byte            | rune                          | []byte         | []rune                     |
| ------------ | -------------------------- | --------------- | ----------------------------- | -------------- | -------------------------- |
| **类型**     | 不可变字节序列             | uint8 (1 字节)  | int32 (4 字节)                | byte 切片      | rune 切片                  |
| **是否可变** | 不可变                     | 不可变          | 不可变                        | 可变           | 可变                       |
| **长度单位** | 字节数（UTF-8）            | 单个字节        | 字符数（Unicode）             | 字节数         | 字符数                     |
| **适用场景** | 处理只读文本、常量字符串   | 处理 ASCII 字符 | 处理多字节字符（中文、emoji） | 处理二进制数据 | 处理多字节字符，按字符操作 |
| **遍历方式** | 按字节遍历（可能导致乱码） | 按字节遍历      | 按字符遍历                    | 按字节遍历     | 按字符遍历                 |
| **转换方式** | -                          | `[]byte(str)`   | `[]rune(str)`                 | `[]byte(str)`  | `[]rune(str)`              |

## 3. 实际示例说明

### 示例 1：字符串长度

```go
str := "你好Go"

// 字符串长度（字节数）
fmt.Println(len(str)) // 输出: 6 (因为"你好"每个字符占3字节)

// 字符数（Unicode字符数）
fmt.Println(len([]rune(str))) // 输出: 4
```

### 示例 2：遍历字符串

```go
str := "你好Go"

// 错误：按字节遍历（中文乱码）
for i := 0; i < len(str); i++ {
    fmt.Printf("字节: %d, 字符: %c\n", str[i], str[i])
}
// 输出：字节: 228, 字符: （乱码）

// 正确：按rune遍历
for i, r := range str {
    fmt.Printf("字符: %c, Unicode码点: %d\n", r, r)
}
// 输出：字符: 你, Unicode码点: 20320
//       字符: 好, Unicode码点: 21037
//       字符: G, Unicode码点: 71
//       字符: o, Unicode码点: 111
```

### 示例 3：字符串反转

```go
str := "你好Go"

// 错误：用[]byte反转（中文字符被拆开）
bytes := []byte(str)
for i, j := 0, len(bytes)-1; i < j; i, j = i+1, j-1 {
    bytes[i], bytes[j] = bytes[j], bytes[i]
}
fmt.Println(string(bytes)) // 输出: o好你（错误）

// 正确：用[]rune反转
runes := []rune(str)
for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
    runes[i], runes[j] = runes[j], runes[i]
}
fmt.Println(string(runes)) // 输出: 好你Go（正确）
```

## 4. 为什么需要 rune

根据知识库[4]的总结：

> "在处理多语言字符时，不要用 byte 用 rune，否则你会掉进中文乱码的坑！"

这是因为：

- 中文字符在 UTF-8 编码中占用 3 个字节
- 如果使用`[]byte`遍历，会把一个中文字符拆成 3 个字节
- 使用`rune`可以将每个字符视为一个单位，正确处理多字节字符

## 5. 使用场景总结

- **string**：处理只读文本、常量字符串、网络通信等
- **[]byte**：处理二进制数据、文件读写、需要修改字符串内容时
- **[]rune**：处理多字节字符（中文、emoji）、需要按字符操作时

## 6. 转换关系

```go
str := "你好"

// string -> []byte
bytes := []byte(str)

// string -> []rune
runes := []rune(str)

// []rune -> string
str2 := string(runes)
```

## 结论

- **string**是不可变的 UTF-8 编码字节序列，长度是字节数
- **byte**和**rune**是基础数据类型，分别表示单个字节和 Unicode 码点
- **[]byte**是字节切片，适合处理二进制数据
- **[]rune**是 rune 切片，适合处理多字节字符（如中文、emoji）

在处理包含中文等多字节字符的字符串时，**一定要使用[]rune**，而不是[]byte，否则会导致乱码或字符处理错误。这是 Go 语言中处理文本数据的关键点。
